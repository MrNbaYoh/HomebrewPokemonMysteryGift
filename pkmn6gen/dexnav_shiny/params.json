{
  "name": "Pokemon ORAS DexNav Shiny Encounter Probability Analysis",
  "tagline": "",
  "body": "### Introduction\r\nMany people have been speculating on the probabilities to find a shiny pokemon with the dexnav on pokemon ORAS, but we don't really know actually what are the probabilities. Some analysis based on real encounters gave some results making us think about a 1/200 or 1/300 probability, but this does not really convinced me. So I decided to do some researches about the actual probabilities and the way the game decide if the pokemon is shiny or not.\r\n\r\n### How a pokemon is considered shiny?\r\nWe know every pokemon has a specific PID which is randomly generated when the pokemon itself is generated. The PID is a 32bits value and the pokemon is shiny if (TID xor SID xor PID_high xor PID_low) < 16. So yeah we have a probability of 16/65536 (65536 is the max value for a unsigned 16bits value) so 1/4096.  \r\nWe know the game can increase the probability with the shiny charm, it computes up to three times the PID if the one generated is not a \"shiny one\". We can think the dexnav is doing something similar, increasing the number of PID computations, but contrary to what we think the \"computation count\" is the same as a normal encounter.\r\n\r\n### How the dexnav could increase the probability?\r\nI investigated how the dexnav is generating the pokemon and before doing anything with the PID, it generates some basic informations that we may see on the bottom screen when we are using the dexnav, such as the pokemon level, id...\r\nThese infos are generated and stored in memory before the pokemon is generated, and analysing them I just found out that these infos contain a boolean value for the shininess of the pokemon. When this value is set to 1, the pokemon is automatically shiny and when it is set to 0 then the PID computation is done like for any normal encounter.  \r\nSo we can think about such a Probability Tree Diagram :  \r\n![](https://mrnbayoh.github.io/pkmn6gen/dexnav_shiny/shiny_tree_first.png)\r\n\r\n### What is the probability that this value is set to 1?\r\nAfter some researches I found out the algorithm used during the generation to determine if this value is either 1 or 0. This is completely different than the PID generation and computation loop. First the game computes a random 16bits integer value between 0 (included) and 10000 (excluded), so 10000 potential values. Then this value is compared to another one computed before (not random) and if the random value is the smallest then the pokemon is shiny.  \r\nSo basically it does something like this : `if random_value < other_value then shiny=1`  \r\nLooking how the other value is calculated, I quickly found out it is based on the search level for the current pokemon, and here is the way it is computed :  \r\n\r\n    double other_value = 0.0;  \r\n    if(level > 200)  \r\n    {  \r\n        other_value += level - 200;  \r\n        level = 200;  \r\n    }  \r\n\r\n    if(level > 100)  \r\n    {  \r\n        other_value += (level * 2) - 200;  \r\n        level = 100;  \r\n    }       \r\n          \r\n    if(level > 0)  \r\n    {  \r\n        other_value += level * 6;  \r\n    }  \r\n    \r\n    other_value *= 0.01;  \r\n\r\nNow we know how to compute the other value but in fact, like for the PID calculation, the random value and the comparison can be done multiple times.  \r\n  \r\nI will now use the terms dexnav_level instead of \"the other value\" and \"dexnav_random\" instead of \"the random value\". So, like the PID calculation the loop generally iterates once without the charm and three times with the charm, but we may remark that even if the condition is satisfied, the loop is not broken. So you could potentially get multiple \"shiny values\" at once (this is pointless).  \r\n  \r\nInvestigating what could alter the number of iterations, I found out that if the pokemon is going to be the 50th of your dexnav chain the loop iterates 5 more times and if it is going to be the 100th then the loop iterates 10 more times, so let's call this the chain_bonus. Let n be the number of times the loop iterates, we have :  \r\n`n = 1 + charm_bonus + chain_bonus`  \r\nwith charm_bonus = 0 without the charm and 2 with the charm.  \r\n\r\nWe can know deal with probabilities. Let C be the event : \"the condition is satisfied\". Since the dexnav_random is an integer and dexnav_level is a floating-point value,  \r\n`if dexnav_random < dexnav_level then dexnav_random < ceil(dexnav_level)`\r\nwith ceil(dexnav_level) being the smallest integer that is greater than dexnav_level. There is actually ceil(dexnav_level) values smaller than dexnav_level (and ceil(dexnav_level) because of the dexnav_random being an integer), so we have :  \r\n`P(C) = ceil(dexnav_level)/10000`  \r\n\r\nSo now we are able to compute the probability of C. So let D be the event : \"the dexnav boolean value is set to 1 (pokemon shiny beacause of the dexnav)\". D is realized only if C is realized at least once during the multiple loop iterations.  \r\nWe have a Bernoulli experiment with a success : C is realized, and a failure : C is not realized. We repeat this experiment n times, and count the number X of success. We want to know the probability that C is realized at least once, so :  \r\n\r\n    P(X >= 1) = 1 - P(X = 0)  \r\n    P(X = 0) = pow(1-P(C), n)  \r\n    P(X >= 1) = 1 - pow(1-P(C), n)  \r\n    P(D) = 1 - pow(1-P(C), n)  \r\n\r\nSo we are now able to determine the probability that the pokemon is set shiny during the dexnav generation process, but don't forget our initial probability tree, even if the pokemon isn't set shiny here, it can still be shiny because of the random PID computation.\r\n\r\n### The final probability\r\nWe need to know the probability to have a shiny PID in any case. Without the shiny charm we have the well-known 1/4096, but with the charm the PID is computed 3 times and the loop is broken if a success occurs (when we get a shiny PID). So it is similar to the previous situation but now the process can be interrupted, we repeat up to 3 times and we stop if a success occurs. It can be illustrated by this tree (3 iterations):  \r\n![](https://mrnbayoh.github.io/pkmn6gen/dexnav_shiny/shiny_tree_second.png)\r\n\r\nWe have X the step for which the success occurs and we consider X=0 if the success do not happen, so we are in the case of a truncated geometric law. Similarly to the previous situation we have :  \r\n`P(X >= 1) = 1 - P(X = 0)`  \r\nand  \r\n`P(X = 0) = pow(4095/4096, n1)`  \r\nwhere n1 is the number of iterations, so finally :  \r\n`P(X >= 1) = 1 - pow(4095/4096, n1)`  \r\nwe have the probability of a shiny PID in any case.  \r\n\r\n**/!\\ Some people are saying the probability with the shiny charm is 3/4096 BECAUSE we compute the PID 3 times, SO the probability is multiplied by 3. This is WRONG, actually it is effectively around 3/4096 but it's not because you repeat 3 times the experiment that the probability is multiplied by 3. /!\\**\r\n\r\nSo finally, we know all the probabilities necessary to compute the final P(S) :  \r\n`P(S) = P(D ∩ S) + P(!D ∩ S)`\r\nand then :  \r\n`P(S) = (1 - pow(1-P(C), n)) * 1 + (1 - (1 - pow(1-P(C), n)) * (1 - pow(4095/4096, n1))`\r\nso we have :  \r\n`P(S) = 1 - pow(1-P(C), n) + pow(1-P(C), n) * (1 - pow(4095/4096, n1))`\r\n\r\n### Conclusion\r\nWe are now able to know what is the probability to find a shiny pokemon, based on the searhc level, the chain and the shiny charm. If you find a mistake, please open an issue on the corresponding github repo :). I quickly implemented a small calculator, see : [6th gen shiny calculator](https://mrnbayoh.github.io/pkmn6gen/shiny_calculator/)",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}