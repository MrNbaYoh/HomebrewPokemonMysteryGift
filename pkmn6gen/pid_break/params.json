{
  "name": "How to \"break\" the PID generation ?",
  "tagline": "",
  "body": "### How is the PID generated?\r\nDoing my researches on how I could make a shiny cheat, I just found the algorithm used to generate a \"random\" PID. My first question was \"Is there a way to make the game generate a shiny PID? What are the conditions to make this algorithm generate a shiny PID?\"  \r\nI worked on that and yes there's a way to do it, and I'm going to explain it right here.  \r\nTo generate a random PID the game use a Mersenne Twister Table, a table containing a large number of random integers. Here is the algorithm used :  \r\n\r\n    unsigned int generatePID()\r\n    {\r\n        unsigned int r0 = (unsigned int)&table;\r\n        unsigned int r1, r2, r3, r4, r5, r12;\r\n        bool t = false;\r\n    \r\n        r3 = *(unsigned int*)r0;\r\n        r1 = r3 + 1;\r\n        r2 = r3 + 0x100;\r\n        r2 = r2 + 0x8D;\r\n    \r\n        if(r1 >= 0x270) r1 -= 0x270;\r\n        if(r2 >= 0x270) r2 -= 0x270;\r\n    \r\n        r12 = (unsigned int)&table + (r1 << 2);\r\n        r3 = (unsigned int)&table + (r3 << 2);\r\n        r5 = (unsigned int)&table + (r2 << 2);\r\n    \r\n        r4 = *(unsigned int*)(r3 + 4);\r\n        r2 = *(unsigned int*)(r12 + 4);\r\n        r12 = *(unsigned int*)(r5 + 4);\r\n    \r\n        r4 = r4 & 0x80000000;\r\n        r5 = r2 & 0x7FFFFFFF;\r\n    \r\n        r4 = r4 | r5;\r\n    \r\n        t = (r2 == 1);\r\n    \r\n        r2 = r4 >> 1;\r\n    \r\n        if(t)\r\n        {\r\n            r4 = 0x9908b0df;\r\n            r2 = r2 ^ r4;\r\n        }\r\n    \r\n        r2 = r2 ^ r12;\r\n    \r\n        r1 = 0x9d2c56ff;\r\n        r0 = r2 ^ (r2 >> 11);\r\n    \r\n        r2 = r1 & (r0 << 7);\r\n        r1 = 0xefc67fff;\r\n        r0 = r0 ^ r2;\r\n        r1 = r1 & (r0 << 15);\r\n        r0 = r0 ^ r1;\r\n        r0 = r0 ^ (r0 >> 18);\r\n    \r\n        return r0;\r\n    }\r\n\r\nIn fact the algorithm writes new values in the table, but it's not important for us. We can see the generation is mainly based on three values picked from the table. The more interesting thing here is that all the algorithm is based on the table and some logical operations.  \r\nFirst we know that we are going to modify the table, and we can simplify the algorithm and get rid of the condition (r2 == 1), we have to put the value 0 where r2 is read. We can also then put the value 0 where r4 is read (r2 and r4 are two consecutive values in the table) so we have an easier algorithm :  \r\n\r\n    unsigned int generatePID()\r\n    {\r\n        unsigned int r0 = (unsigned int)&table;\r\n        unsigned int r1, r2, r3, r4, r5, r12;\r\n        bool t = false;\r\n    \r\n        r3 = *(unsigned int*)r0;\r\n        r1 = r3 + 1;\r\n        r2 = r3 + 0x100;\r\n        r2 = r2 + 0x8D;\r\n    \r\n        if(r1 >= 0x270) r1 -= 0x270;\r\n        if(r2 >= 0x270) r2 -= 0x270;\r\n    \r\n        r12 = (unsigned int)&table + (r1 << 2);\r\n        r3 = (unsigned int)&table + (r3 << 2);\r\n        r5 = (unsigned int)&table + (r2 << 2);\r\n    \r\n        r4 = 0;\r\n        r2 = 0;\r\n        r12 = *(unsigned int*)(r5 + 4);\r\n    \r\n        r2 = r12;\r\n    \r\n        r1 = 0x9d2c56ff;\r\n        r0 = r2 ^ (r2 >> 11);\r\n    \r\n        r2 = r1 & (r0 << 7);\r\n        r1 = 0xefc67fff;\r\n        r0 = r0 ^ r2;\r\n        r1 = r1 & (r0 << 15);\r\n        r0 = r0 ^ r1;\r\n        r0 = r0 ^ (r0 >> 18);\r\n    \r\n        return r0;\r\n    }\r\n\r\nThe interesting part starts after r12 is read, we can express the final r0 in terms of the value of r12 :)  \r\n`unsigned int F = R12 ^ ((R12) >> 11) ^ (0x9D2C56FF & ((R12 ^ ((R12) >> 11)) << 7)) ^ (0xEFC67FFF & (((R12 ^ ((R12) >> 11)) ^ (0x9D2C56FF & ((R12 ^ ((R12) >> 11)) << 7))) << 15)) ^ ((((R12 ^ ((R12) >> 11)) ^ (0x9D2C56FF & ((R12 ^ ((R12) >> 11)) << 7))) ^ (0xEFC67FFF & (((R12 ^ ((R12) >> 11)) ^ (0x9D2C56FF & ((R12 ^ ((R12) >> 11)) << 7))) << 15))) >> 18);`  \r\n\r\n### Finding bits formula\r\nWe can now find, for each bit of the final value, an expression based on R12. (here all the '+' mean XOR, sorry :S)  \r\nLet B[X] be the Xth bit of R12 :  \r\n[PID](https://github.com/MrNbaYoh/pkmn6gen/pid_break/PID_R12.PNG)  \r\n\r\nSo we can have PID_HIGH xor PID_LOW too and since X xor X = 0, we can simplify each expression and we have :  \r\n[PID](https://github.com/MrNbaYoh/pkmn6gen/pid_break/PID_LOW_XOR_HIGH.PNG)\r\n\r\nWe want PID_HIGH xor PID_LOW xor TID xor SID < 16, so the first four bits do no matter because a four bits value is always less than 16. To have PID_HIGH xor PID_LOW xor TID xor SID < 16, we need to have the last 12 bits of (PID_HIGH xor PID_LOW) equal to the last 12 bits of (TID xor SID), so when we xor the two values, these bits are cleared.  \r\n\r\n### Solving the system of equation\r\nTo solve the 12bits equation we can treat the problem with a matrix, we can make a matrix of coefficients, as if we were solving a linear system of equation, the particularity here is that each operation is a XOR and each coefficient is 1 or 0. So we have something like that, each column stand for each bit of R12 with the corresponding coefficient in each expression of each bit of the 12 highest bits of PID_HIGH xor PID_LOW :  \r\n[PID](https://github.com/MrNbaYoh/pkmn6gen/pid_break/PID_Matrix_1.PNG)  \r\n\r\nWith a modified version of the Gauss-Jordan algorithm a got a staggered matrix :  \r\n[PID](https://github.com/MrNbaYoh/pkmn6gen/pid_break/PID_Matrix_2.PNG)  \r\n\r\nThis allowed me to find what are the bits of R12 that can be randomly chosen and the one we have to compute, based on the bits of the highest 12 bits of (TID xor SID) and the other random bits of R12.  \r\nSo I ended up with this :  \r\n[PID](https://github.com/MrNbaYoh/pkmn6gen/pid_break/PID_Formula_Final.PNG)  \r\n\r\nWhere B[X] is the Xth bit of R12 and A[X] is the Xth bit of the highest 12bits of (TID xor SID).\r\n\r\n### Conclusion\r\nWe are now able to generate a random number and then modify some bits to make the game generate a shiny PID. We have to compute an integer with the final formulas we got in the previous part and write it to the table where R12 is read (and write some 0 where r2 and r4 are read). The result of this work is the newest shiny cheat plugin that you can find here : https://github.com/hartmannaf/PokemonCheatPlugin  \r\nWe can now say the shiny PID equation is solved ;)",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}